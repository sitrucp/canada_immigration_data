<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TFW Sankey — Province & Year Filters</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="d3-sankey.js"></script>
  <style>
    body { 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
      margin: 24px; 
    }
    h1 { 
      font-size: 20px; 
      margin: 0 0 8px; 
    }
    .controls { 
      display: flex; 
      flex-wrap: wrap; 
      gap: 12px; 
      align-items: center; 
      margin-bottom: 12px; 
    }
    .controls label { 
      font-weight: 600; 
      font-size: 14px; 
      margin-right: 6px; 
    }
    select { 
      padding: 6px 8px; 
      border-radius: 8px; 
      border: 1px solid #ccc; 
    }
    #chart { 
      width: 100%; 
      height: 720px; 
      overflow: visible;
    }
    .pill { 
      display:inline-block; 
      padding:2px 8px; 
      border:1px solid #ccc; 
      border-radius:999px; 
      margin-left:6px; 
      font-size:12px; 
      color:#333; 
    }
    
    /* D3 Sankey Styles */
    .node rect {
      fill-opacity: 0.9;
      shape-rendering: crispEdges;
      /* stroke and stroke-width now set dynamically for minimum-height nodes */
    }
    .node text {
      font-size: 11px;
      pointer-events: none;
    }
    .link {
      fill: none;
      stroke: rgba(0,0,0,0.2);
      stroke-opacity: 0.5;
    }
    .link:hover {
      stroke-opacity: 0.8;
    }
    
    /* Tooltip */
    .tooltip {
      position: absolute;
      padding: 8px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1000;
    }
    /* Navigation */
    .nav {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 12px 24px;
      margin: -24px -24px 20px -24px;
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }
    .nav a {
      color: white;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      padding: 6px 12px;
      border-radius: 6px;
      transition: background 0.2s;
    }
    .nav a:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    .nav a.active {
      background: rgba(255, 255, 255, 0.3);
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="nav">
    <a href="index.html">← Home</a>
    <a href="sankey_imp.html">IMP Sankey</a>
    <a href="sankey_tfw.html" class="active">TFW Sankey</a>
    <a href="sankey_pr.html">PR Sankey</a>
  </div>
  <h1>TFW Sankey — Province & Year Filters</h1>
  <div class="controls">
    <div>
      <label for="provinceSelect">Province/Territory</label>
      <select id="provinceSelect">
        <option value="ALL" selected>All</option>
      </select>
    </div>
    <div>
      <label for="yearSelect">Year</label>
      <select id="yearSelect">
        <option value="ALL" selected>All</option>
      </select>
    </div>
    <span id="summary" class="pill">All provinces · All years</span>
  </div>
  <div id="chart"></div>
  
  <!-- Small/Zero Value Nodes Legend -->
  <div id="small-nodes-legend" style="margin-top: 16px; font-size: 11px; color: #666;"></div>

  <!-- Tooltip -->
  <div class="tooltip" id="tooltip"></div>

  <!-- The Python script will inject data below by replacing the placeholders. -->
  <script>
    // BEGIN DATA (auto-generated — do not edit by hand)
    const NODES = /*__NODES_JSON__*/ [];
    const LINKS = /*__LINKS_JSON__*/ [];
    // END DATA
  </script>

  <script>
    // Setup
    const margin = {top: 10, right: 10, bottom: 10, left: 10};
    const width = document.getElementById('chart').clientWidth - margin.left - margin.right;
    const height = 720 - margin.top - margin.bottom;

    const provinceSel = document.getElementById('provinceSelect');
    const yearSel = document.getElementById('yearSelect');
    const summaryEl = document.getElementById('summary');
    const tooltip = d3.select('#tooltip');

    // Format numbers
    function formatNumber(num) {
      if (num >= 1000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
      if (num >= 1000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
      return num.toString();
    }

    function init() {
      // Build filter lists from links
      const provs = Array.from(new Set(LINKS.map(l => String(l.province_territory)))).sort();
      const years = Array.from(new Set(LINKS.map(l => String(l.year)))).sort((a,b)=>a.localeCompare(b));

      for (const p of provs) {
        const opt = document.createElement('option');
        opt.value = p;
        opt.textContent = p;
        provinceSel.appendChild(opt);
      }
      for (const y of years) {
        const opt = document.createElement('option');
        opt.value = y;
        opt.textContent = y;
        yearSel.appendChild(opt);
      }

      provinceSel.addEventListener('change', render);
      yearSel.addEventListener('change', render);

      render();
    }

    function render() {
      const p = provinceSel.value;
      const y = yearSel.value;

      // Filter links
      const filtered = LINKS.filter(l => 
        (p === 'ALL' || String(l.province_territory) === p) &&
        (y === 'ALL' || String(l.year) === y)
      );

      // Aggregate links
      const edgeMap = new Map();
      let totalValue = 0;
      for (const row of filtered) {
        const s = Number(row.source);
        const t = Number(row.target);
        const v = Number(row.value) || 0;
        const key = `${s}-${t}`;
        totalValue += v;
        if (!edgeMap.has(key)) {
          edgeMap.set(key, {source: s, target: t, value: 0});
        }
        edgeMap.get(key).value += v;
      }
      const aggregatedLinks = Array.from(edgeMap.values());

      // Update summary
      summaryEl.textContent = `${p==='ALL'?'All provinces':p} · ${y==='ALL'?'All years':y}`;

      // Count nodes with values
      const nodeValues = new Map();
      for (const link of aggregatedLinks) {
        nodeValues.set(link.source, (nodeValues.get(link.source) || 0) + link.value);
        nodeValues.set(link.target, (nodeValues.get(link.target) || 0) + link.value);
      }
      // Build hierarchy paths for nodes using original link structure
      function getNodePath(nodeId) {
        const node = NODES.find(n => n.id === nodeId);
        if (!node) return '';
        
        const path = [];
        let currentId = nodeId;
        const maxDepth = 10; // Safety limit
        let depth = 0;
        
        // Walk up the hierarchy using ALL links (not filtered), to show structural hierarchy
        while (currentId !== undefined && depth < maxDepth) {
          const currentNode = NODES.find(n => n.id === currentId);
          if (currentNode && currentNode.level !== 0) { // Skip "TFW" root
            path.unshift(currentNode.label);
          }
          
          // Find parent using any link (from original LINKS, not aggregated)
          const parentLink = LINKS.find(l => l.target === currentId);
          currentId = parentLink ? parentLink.source : undefined;
          depth++;
        }
        
        return path.join(' → ');
      }
      
      // Display zero-flow nodes with hierarchy
      const legendDiv = document.getElementById('small-nodes-legend');
      
      // Only show nodes with exactly zero flow (not in nodeValues)
      const zeroFlowNodes = NODES.filter(n => 
        n.level > 0 && !nodeValues.has(n.id)
      ).map(n => [n.id, 0]);
      
      if (zeroFlowNodes.length > 0) {
        const nodesWithPaths = zeroFlowNodes.map(([id, val]) => ({
          id,
          value: val,
          path: getNodePath(id)
        })).sort((a, b) => a.path.localeCompare(b.path));
        
        legendDiv.innerHTML = `
          <strong>Nodes with zero flow (${zeroFlowNodes.length}):</strong>
          <div style="columns: 2; column-gap: 20px; margin-top: 8px;">
            ${nodesWithPaths.map(n => 
              `<div style="margin-bottom: 4px; break-inside: avoid;">
                <span style="color: #999;">▪</span> ${n.path} <span style="color: #999;">(0)</span>
              </div>`
            ).join('')}
          </div>
        `;
      } else {
        legendDiv.innerHTML = '';
      }

      // Prepare D3 Sankey data
      // Include ALL nodes with flow > 0 (only zero-flow nodes go to legend)
      const nodesWithFlow = new Set(nodeValues.keys());
      
      // D3 Sankey needs nodes as objects with name property and modifies them in place
      const sankeyNodes = NODES
        .filter(n => nodesWithFlow.has(n.id)) // Only exclude zero-flow nodes
        .map(n => ({
          id: n.id,
          name: n.label,
          level: n.level
        }));

      const sankeyLinks = aggregatedLinks.map(l => ({
        source: l.source,
        target: l.target,
        value: l.value
      }));

      // Create parent-child mapping for hierarchical grouping
      const parentMap = new Map(); // childId -> primaryParentId
      const childrenMap = new Map(); // parentId -> Set of childIds
      
      for (const link of sankeyLinks) {
        // Track primary parent for each child
        if (!parentMap.has(link.target)) {
          parentMap.set(link.target, link.source);
        }
        // Track all children for each parent
        if (!childrenMap.has(link.source)) {
          childrenMap.set(link.source, new Set());
        }
        childrenMap.get(link.source).add(link.target);
      }
      
      // Calculate node order: first by level, then by value within level, then by parent order
      const nodeOrder = new Map();
      let orderCounter = 0;
      
      // Get nodes by level
      const nodesByLevel = new Map();
      for (const node of sankeyNodes) {
        const level = node.level || 0;
        if (!nodesByLevel.has(level)) {
          nodesByLevel.set(level, []);
        }
        nodesByLevel.get(level).push(node);
      }
      
      // Sort each level hierarchically
      const maxLevel = Math.max(...Array.from(nodesByLevel.keys()));
      for (let level = 0; level <= maxLevel; level++) {
        const nodesAtLevel = nodesByLevel.get(level) || [];
        
        if (level === 0) {
          // Level 0: just assign order
          nodesAtLevel.forEach(node => {
            nodeOrder.set(node.id, orderCounter++);
          });
          } else {
          // Group by parent, maintaining parent order
          const grouped = new Map(); // parentId -> children
          const orphans = []; // nodes without parents
          
          for (const node of nodesAtLevel) {
            const parentId = parentMap.get(node.id);
            if (parentId === undefined) {
              orphans.push(node);
              } else {
              if (!grouped.has(parentId)) {
                grouped.set(parentId, []);
              }
              grouped.get(parentId).push(node);
            }
          }
          
          // Sort orphans by value
          orphans.sort((a, b) => (b.value || 0) - (a.value || 0));
          orphans.forEach(node => {
            nodeOrder.set(node.id, orderCounter++);
          });
          
          // Get parents sorted by their order
          const sortedParents = Array.from(grouped.keys())
            .sort((a, b) => (nodeOrder.get(a) || 0) - (nodeOrder.get(b) || 0));
          
          // Process children in parent order
          for (const parentId of sortedParents) {
            const children = grouped.get(parentId);
            // Sort children within parent by value (descending)
            children.sort((a, b) => (b.value || 0) - (a.value || 0));
            children.forEach(node => {
              nodeOrder.set(node.id, orderCounter++);
            });
          }
        }
      }
      
      // Hierarchical sort function using pre-calculated order
      function hierarchicalSort(a, b) {
        const orderA = nodeOrder.get(a.id);
        const orderB = nodeOrder.get(b.id);
        return (orderA || 0) - (orderB || 0);
      }
      
      // Create Sankey generator with hierarchical grouping
      const sankey = d3.sankey()
        .nodeId(d => d.id)
        .nodeAlign(d3.sankeyLeft)  // Align nodes by depth/level
        .nodeWidth(20)
        .nodePadding(15)  // Vertical spacing between nodes
        .nodeSort(hierarchicalSort)  // Group children under their parents
        .extent([[margin.left, margin.top], [width - margin.right, height - margin.bottom]]);

      // Generate the sankey layout
      const graph = sankey({
        nodes: sankeyNodes,
        links: sankeyLinks
      });

      // Build color mapping: all nodes inherit color from their Category 1 parent
      const nodeToCategory1 = new Map();
      
      // Find Category 1 parents for all nodes
      function findCategory1Parent(nodeId, visited = new Set()) {
        if (visited.has(nodeId)) return null; // Prevent infinite loops
        visited.add(nodeId);
        
        const node = graph.nodes.find(n => n.id === nodeId);
        if (!node) return null;
        
        // If this is a Category 1 node (level 1), return it
        if (node.level === 1) return nodeId;
        
        // Find parent through links
        const parentLink = graph.links.find(l => l.target.id === nodeId);
        if (parentLink) {
          return findCategory1Parent(parentLink.source.id, visited);
        }
        
        return null;
      }
      
      // Map all nodes to their Category 1 parent
      for (const node of graph.nodes) {
        const cat1Parent = findCategory1Parent(node.id);
        nodeToCategory1.set(node.id, cat1Parent);
      }
      
      // Create color scale based on Category 1 nodes only
      const category1Nodes = graph.nodes.filter(n => n.level === 1);
      const category1Colors = new Map();
      category1Nodes.forEach((node, i) => {
        category1Colors.set(node.id, d3.schemeCategory10[i % 10]);
      });
      
      // Function to get color for any node based on its Category 1 parent
      function getNodeColor(nodeId) {
        const cat1Parent = nodeToCategory1.get(nodeId);
        if (cat1Parent && category1Colors.has(cat1Parent)) {
          return category1Colors.get(cat1Parent);
        }
        // Default color for nodes without Category 1 parent (like root)
        return '#999';
      }

      // Clear previous chart
      d3.select('#chart').selectAll('*').remove();

      // Create SVG
      const svg = d3.select('#chart')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      // Add links
      const link = svg.append('g')
        .attr('class', 'links')
        .selectAll('path')
        .data(graph.links)
        .join('path')
        .attr('class', 'link')
        .attr('d', d3.sankeyLinkHorizontal())
        .attr('stroke-width', d => Math.max(1, d.width))
        .attr('stroke', d => {
          // Use the target node's Category 1 color for the link
          const color = getNodeColor(d.target.id);
          // Add transparency
          const rgb = d3.color(color);
          return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.4)`;
        })
        .on('mouseover', function(event, d) {
          d3.select(this).attr('stroke-opacity', 0.8);
          tooltip
            .style('opacity', 1)
            .html(`${d.source.name} → ${d.target.name}<br/>Value: ${formatNumber(d.value)}`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px');
        })
        .on('mousemove', function(event) {
          tooltip
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px');
        })
        .on('mouseout', function() {
          d3.select(this).attr('stroke-opacity', 0.5);
          tooltip.style('opacity', 0);
        });

      // Add nodes
      const node = svg.append('g')
        .attr('class', 'nodes')
        .selectAll('g')
        .data(graph.nodes)
        .join('g')
        .attr('class', 'node');

      // Add node rectangles with minimum height for visibility
      const MIN_NODE_HEIGHT = 3; // Minimum 3px height even for tiny values
      
      node.append('rect')
        .attr('x', d => d.x0)
        .attr('y', d => {
          const actualHeight = d.y1 - d.y0;
          return actualHeight < MIN_NODE_HEIGHT ? d.y0 - (MIN_NODE_HEIGHT - actualHeight) / 2 : d.y0;
        })
        .attr('height', d => Math.max(MIN_NODE_HEIGHT, d.y1 - d.y0))
        .attr('width', d => d.x1 - d.x0)
        .attr('fill', d => getNodeColor(d.id))
        .attr('stroke', '#999')
        .attr('stroke-width', 0.5)
        .on('mouseover', function(event, d) {
          tooltip
            .style('opacity', 1)
            .html(`${d.name}<br/>Value: ${formatNumber(d.value || 0)}`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px');
        })
        .on('mousemove', function(event) {
          tooltip
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px');
        })
        .on('mouseout', function() {
          tooltip.style('opacity', 0);
        });

      // Add node labels (single line, no wrapping)
      node.append('text')
        .attr('x', d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
        .attr('y', d => (d.y1 + d.y0) / 2)
        .attr('dy', '0.35em')
        .attr('text-anchor', d => d.x0 < width / 2 ? 'start' : 'end')
        .text(d => {
          const val = d.value || 0;
          return val > 0 ? `${d.name} (${formatNumber(val)})` : d.name;
        });
    }

    init();
  </script>
</body>
</html>

