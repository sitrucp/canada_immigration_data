<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Study Sankey</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@6.0.0/dist/echarts.min.js"></script>
  <style>
    body { 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
      margin: 24px; 
    }
    h1 { 
      font-size: 20px; 
      margin: 0 0 8px; 
    }
    .controls { 
      display: flex; 
      flex-wrap: wrap; 
      gap: 12px; 
      align-items: center; 
      margin-bottom: 12px; 
    }
    .controls label { 
      font-weight: 600; 
      font-size: 14px; 
      margin-right: 6px; 
    }
    select { 
      padding: 6px 8px; 
      border-radius: 8px; 
      border: 1px solid #ccc; 
    }
    #chart { 
      width: 100%; 
      height: 590px; 
    }
    .pill { 
      display:inline-block; 
      padding:6px 8px; 
      border:1px solid #ccc; 
      border-radius:999px; 
      margin-left:6px; 
      font-size:14px; 
      color:#333; 
    }
    
    /* Navigation */
    .nav {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 12px 24px;
      margin: -24px -24px 20px -24px;
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }
    .nav a {
      color: white;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      padding: 6px 12px;
      border-radius: 6px;
      transition: background 0.2s;
    }
    .nav a:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    .nav a.active {
      background: rgba(255, 255, 255, 0.3);
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="nav">
    <a href="index.html">← Home</a>
    <a href="sankey_imp.html">IMP Sankey</a>
    <a href="sankey_tfw.html">TFW Sankey</a>
    <a href="sankey_pr.html">PR Sankey</a>
    <a href="sankey_asylum.html">Asylum Sankey</a>
    <a href="sankey_study.html" class="active">Study Sankey</a>
  </div>
  <h1>Study Sankey</h1>
  <div class="controls">
    <div>
      <label for="provinceSelect">Province/Territory</label>
      <select id="provinceSelect">
        <option value="ALL" selected>All</option>
      </select>
    </div>
    <div>
      <label for="yearSelect">Year</label>
      <select id="yearSelect">
        <option value="ALL" selected>All</option>
      </select>
    </div>
    <span id="summary" class="pill">All provinces · All years</span>
  </div>
  <div id="chart"></div>
  <div id="zeroValues" style="display: none; margin-top: 20px; padding: 16px; clear: both; position: relative; z-index: 1;">
    <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #495057;">Zero Value Categories</h3>
    <div id="zeroValuesList" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
  </div>

  <!-- The Python script will inject data below by replacing the placeholders. -->
  <script>
    // BEGIN DATA (auto-generated — do not edit by hand)
    const NODES = /*__NODES_JSON__*/ [];
    const LINKS = /*__LINKS_JSON__*/ [];
    const COLOR_SCHEMA = /*__COLOR_SCHEMA_JSON__*/ {};
    // END DATA
  </script>

  <script>
    // Initialize ECharts
    const chartDom = document.getElementById('chart');
    const myChart = echarts.init(chartDom);

    const provinceSel = document.getElementById('provinceSelect');
    const yearSel = document.getElementById('yearSelect');
    const summaryEl = document.getElementById('summary');
    const zeroValuesEl = document.getElementById('zeroValues');
    const zeroValuesListEl = document.getElementById('zeroValuesList');

    // Format numbers
    function formatNumber(num) {
      if (num >= 1000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
      if (num >= 1000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
      return num.toString();
    }

    // Color scheme for different branches from root
    const branchColors = [
      '#e74c3c',  // Red
      '#3498db',  // Blue
      '#2ecc71',  // Green
      '#f39c12',  // Orange
      '#9b59b6',  // Purple
      '#1abc9c',  // Turquoise
      '#e67e22',  // Dark Orange
      '#34495e',  // Dark Blue
      '#e91e63',  // Pink
      '#00bcd4'   // Cyan
    ];

    function init() {
      // Build filter lists from links
      const provs = Array.from(new Set(LINKS.map(l => String(l.province_territory)))).sort();
      const years = Array.from(new Set(LINKS.map(l => String(l.year)))).sort((a,b)=>a.localeCompare(b));

      for (const p of provs) {
        const opt = document.createElement('option');
        opt.value = p;
        opt.textContent = p;
        provinceSel.appendChild(opt);
      }
      for (const y of years) {
        const opt = document.createElement('option');
        opt.value = y;
        opt.textContent = y;
        yearSel.appendChild(opt);
      }

      provinceSel.addEventListener('change', render);
      yearSel.addEventListener('change', render);

      render();
    }

    // Function to assign colors to branches using pre-assigned color schema
    function assignBranchColors(links) {
      const nodeColors = {};
      const linkColors = {};
      
      // Find root node (Study)
      const rootNode = 'Study';
      nodeColors[rootNode] = '#808080'; // Gray color for root node
      
      // Get all direct children of root
      const rootChildren = links
        .filter(link => link.source === rootNode)
        .map(link => link.target);
      
      // Assign colors using pre-assigned color schema
      rootChildren.forEach((child) => {
        // Use pre-assigned color from COLOR_SCHEMA
        const branchColor = COLOR_SCHEMA[child];
        
        if (branchColor) {
          // Color the direct child
          nodeColors[child] = branchColor;
          
          // Color the link from root to child
          const rootLink = links.find(link => link.source === rootNode && link.target === child);
          if (rootLink) {
            linkColors[`${rootNode}-${child}`] = branchColor;
          }
          
          // Recursively color all downstream nodes and links
          colorDownstream(child, branchColor, links, nodeColors, linkColors);
        }
      });
      
      return { nodeColors, linkColors };
    }
    
    function colorDownstream(node, color, links, nodeColors, linkColors) {
      // Find all children of this node
      const children = links
        .filter(link => link.source === node)
        .map(link => link.target);
      
      children.forEach(child => {
        // Color the child node
        nodeColors[child] = color;
        
        // Color the link
        const linkKey = `${node}-${child}`;
        linkColors[linkKey] = color;
        
        // Recursively color downstream
        colorDownstream(child, color, links, nodeColors, linkColors);
      });
    }

    function render() {
      const p = provinceSel.value;
      const y = yearSel.value;

      // Filter links
      const filtered = LINKS.filter(l => 
        (p === 'ALL' || String(l.province_territory) === p) &&
        (y === 'ALL' || String(l.year) === y)
      );

      // Aggregate links by source-target pairs
      const edgeMap = new Map();
      for (const row of filtered) {
        const key = `${row.source}-${row.target}`;
        if (!edgeMap.has(key)) {
          edgeMap.set(key, {
            source: row.source,
            target: row.target,
            value: 0
          });
        }
        edgeMap.get(key).value += row.value;
      }
      const aggregatedLinks = Array.from(edgeMap.values());

      // Assign colors to branches
      const { nodeColors, linkColors } = assignBranchColors(aggregatedLinks);

      // Update summary
      summaryEl.textContent = `${p==='ALL'?'All provinces':p} · ${y==='ALL'?'All years':y}`;

      // Create node level mapping and calculate node values
      const nodeLevels = {};
      const nodeValues = {};
      
      // Calculate total value for each node (only count outgoing flow to avoid double counting)
      aggregatedLinks.forEach(link => {
        // For source nodes, count outgoing flow
        nodeValues[link.source] = (nodeValues[link.source] || 0) + link.value;
        // For target nodes, only count if they don't have outgoing flow (leaf nodes)
        if (!nodeValues[link.target]) {
          nodeValues[link.target] = 0;
        }
        // Only add incoming flow if this node has no outgoing flow
        const hasOutgoing = aggregatedLinks.some(l => l.source === link.target);
        if (!hasOutgoing) {
          nodeValues[link.target] += link.value;
        }
      });
      
      // Filter out zero value nodes from chart data
      const nodesWithValues = NODES.filter(node => (nodeValues[node] || 0) > 0);
      
      // Filter links to only include those connecting nodes with values
      const filteredLinks = aggregatedLinks.filter(link => 
        (nodeValues[link.source] || 0) > 0 && (nodeValues[link.target] || 0) > 0
      );
      
      // Use explicit level assignment - Study has only 2 levels: [Study] + study_level
      let currentLevel = 0;
      let nodeIndex = 0;
      
      // Level 0: Study (first node)
      if (NODES.length > 0) {
        nodeLevels[NODES[0]] = 0;
        nodeIndex = 1;
      }
      
      // Find the boundaries between levels by looking at the data structure
      const studyLevelNodes = new Set();
      
      // Analyze links to determine which nodes belong to which category
      aggregatedLinks.forEach(link => {
        // If source is Study, target is study_level
        if (link.source === 'Study') {
          studyLevelNodes.add(link.target);
        }
      });
      
      // Assign levels based on category membership
      NODES.forEach(node => {
        if (node === 'Study') {
          nodeLevels[node] = 0;
        } else if (studyLevelNodes.has(node)) {
          nodeLevels[node] = 1;
        } else {
          // Fallback: try to infer from position in NODES array
          const index = NODES.indexOf(node);
          if (index <= 1) nodeLevels[node] = 1;
          else nodeLevels[node] = 1;
        }
      });
      

      // Create parent-child mapping for hierarchical sorting
      const parentMap = new Map(); // childId -> parentId
      const childrenMap = new Map(); // parentId -> Set of childIds
      
      aggregatedLinks.forEach(link => {
        parentMap.set(link.target, link.source);
        if (!childrenMap.has(link.source)) {
          childrenMap.set(link.source, new Set());
        }
        childrenMap.get(link.source).add(link.target);
      });
      
      // Calculate node order: first by level, then by value within level, then by parent order
      const nodeOrder = new Map();
      let orderCounter = 0;
      
      // Get nodes by level
      const nodesByLevel = new Map();
      NODES.forEach(node => {
        const level = nodeLevels[node] || 0;
        if (!nodesByLevel.has(level)) {
          nodesByLevel.set(level, []);
        }
        nodesByLevel.get(level).push(node);
      });
      
      // Sort each level hierarchically
      const maxLevel = Math.max(...Array.from(nodesByLevel.keys()));
      for (let level = 0; level <= maxLevel; level++) {
        const nodesAtLevel = nodesByLevel.get(level) || [];
        
        if (level === 0) {
          // Level 0: just assign order
          nodesAtLevel.forEach(node => {
            nodeOrder.set(node, orderCounter++);
          });
        } else if (level === 1) {
          // Level 1: sort by value (descending) - these are direct children of Study
          const sortedLevel1 = nodesAtLevel.sort((a, b) => (nodeValues[b] || 0) - (nodeValues[a] || 0));
          sortedLevel1.forEach(node => {
            nodeOrder.set(node, orderCounter++);
          });
        } else {
          // Group by parent, maintaining parent order
          const grouped = new Map(); // parentId -> children
          const orphans = []; // nodes without parents
          
          for (const node of nodesAtLevel) {
            const parentId = parentMap.get(node);
            if (parentId === undefined) {
              orphans.push(node);
            } else {
              if (!grouped.has(parentId)) {
                grouped.set(parentId, []);
              }
              grouped.get(parentId).push(node);
            }
          }
          
          // Sort orphans by value
          orphans.sort((a, b) => (nodeValues[b] || 0) - (nodeValues[a] || 0));
          orphans.forEach(node => {
            nodeOrder.set(node, orderCounter++);
          });
          
          // Get parents sorted by their order
          const sortedParents = Array.from(grouped.keys())
            .sort((a, b) => (nodeOrder.get(a) || 0) - (nodeOrder.get(b) || 0));
          
          
          // Process children in parent order
          for (const parentId of sortedParents) {
            const children = grouped.get(parentId);
            // Sort children within parent by value (descending)
            children.sort((a, b) => (nodeValues[b] || 0) - (nodeValues[a] || 0));
            
            
            children.forEach(node => {
              nodeOrder.set(node, orderCounter++);
            });
          }
        }
      }
      
      // Sort nodes using the hierarchical order (only nodes with values)
      const sortedNodes = nodesWithValues.slice().sort((a, b) => {
        const orderA = nodeOrder.get(a) || 0;
        const orderB = nodeOrder.get(b) || 0;
        return orderA - orderB;
      });

      // Create ECharts option
      const option = {
        tooltip: {
          trigger: 'item',
          triggerOn: 'click',
          formatter: function(params) {
            if (params.dataType === 'node') {
              const nodeName = params.name;
              const nodeValue = params.value || 0;
              const fullValue = nodeValue.toLocaleString();
              
              // Find parent node and calculate percentage
              const parentLink = aggregatedLinks.find(link => link.target === nodeName);
              let percentage = '';
              if (parentLink) {
                const parentValue = nodeValues[parentLink.source] || 0;
                if (parentValue > 0) {
                  const percent = ((nodeValue / parentValue) * 100).toFixed(1);
                  percentage = ` (${percent}%)`;
                }
              }
              
              return `${nodeName}<br/>${fullValue}${percentage}`;
            } else if (params.dataType === 'edge') {
              return `${params.data.source} → ${params.data.target}<br/>Value: ${formatNumber(params.data.value)}`;
            }
            return '';
          }
        },
        series: [
          {
            type: 'sankey',
            left: 100,
            right: 50,
            top: 20,
            bottom: 20,
            data: sortedNodes.map(node => ({
              name: node,
              itemStyle: {
                color: nodeColors[node] || '#999'
              },
              label: {
                position: 'left',
                align: 'right',
                textStyle: {
                  textBorderWidth: 0,
                  textShadowBlur: 0,
                  textShadowColor: 'transparent',
                  textBorderColor: 'transparent',
                  backgroundColor: 'transparent',
                  borderColor: 'transparent',
                  borderWidth: 0
                },
                formatter: function(params) {
                  const nodeName = params.name;
                  const nodeValue = nodeValues[nodeName] || 0;
                  const formattedValue = formatNumber(nodeValue);
                  
                  // Find parent node and calculate percentage
                  const parentLink = aggregatedLinks.find(link => link.target === nodeName);
                  let valuePart;
                  if (parentLink) {
                    const parentValue = nodeValues[parentLink.source] || 0;
                    const percentage = parentValue > 0 ? ((nodeValue / parentValue) * 100).toFixed(1) : '0.0';
                    valuePart = ` (${formattedValue}, ${percentage}%)`;
                  } else {
                    valuePart = ` (${formattedValue})`;
                  }
                  
                  // Calculate how much space we have for the node name
                  const maxChars = 60;
                  const availableForName = maxChars - valuePart.length;
                  
                  // Truncate only the node name, keep values and percentages
                  const truncatedName = nodeName.length > availableForName ? 
                    nodeName.substring(0, availableForName) + '...' : nodeName;
                  
                  return truncatedName + valuePart;
                }
              }
            })),
            links: filteredLinks.map(link => ({
              ...link,
              lineStyle: {
                color: linkColors[`${link.source}-${link.target}`] || '#ccc',
                opacity: 0.4
              }
            })),
            emphasis: {
              focus: 'trajectory'
            },
            lineStyle: {
              curveness: 0.3
            },
            nodeAlign: 'left',
            nodeGap: 14,
            nodeWidth: 20,
            layoutIterations: 0
          }
        ]
      };

      // Set the option and render
      myChart.setOption(option, true);
      
      // Update zero values list
      updateZeroValuesList(aggregatedLinks, nodeValues, parentMap);
    }
    
    function updateZeroValuesList(links, nodeValues, parentMap) {
      // Find all nodes that have zero value
      const zeroValueNodes = NODES.filter(node => (nodeValues[node] || 0) === 0);
      
      if (zeroValueNodes.length > 0) {
        // Show the zero values section
        zeroValuesEl.style.display = 'block';
        
        // Clear and populate the list
        zeroValuesListEl.innerHTML = '';
        
        // Create hierarchy paths for zero value nodes
        const hierarchyPaths = zeroValueNodes.map(node => {
          return buildHierarchyPath(node, parentMap);
        });
        
        // Sort alphabetically
        hierarchyPaths.sort();
        
        // Create bullet point list with colored squares
        const ul = document.createElement('ul');
        ul.style.cssText = 'margin: 0; padding-left: 20px; list-style: none;';
        
        hierarchyPaths.forEach(path => {
          const li = document.createElement('li');
          li.style.cssText = 'margin: 4px 0; font-size: 13px; color: #495057; display: flex; align-items: center;';
          
          // Extract the top-level node from the path (first part before ' > ')
          const topLevelNode = path.split(' > ')[0];
          const bulletColor = COLOR_SCHEMA[topLevelNode] || '#999999';
          
          // Create colored square bullet
          const bullet = document.createElement('span');
          bullet.style.cssText = `display: inline-block; width: 12px; height: 12px; background-color: ${bulletColor}; margin-right: 8px; border-radius: 2px;`;
          
          // Create text content
          const textSpan = document.createElement('span');
          textSpan.textContent = path;
          
          li.appendChild(bullet);
          li.appendChild(textSpan);
          ul.appendChild(li);
        });
        
        zeroValuesListEl.appendChild(ul);
      } else {
        // Hide the zero values section
        zeroValuesEl.style.display = 'none';
      }
    }
    
    function buildHierarchyPath(node, parentMap) {
      // Create parent map from original unfiltered data for hierarchy building
      const originalParentMap = new Map();
      LINKS.forEach(link => {
        originalParentMap.set(link.target, link.source);
      });
      
      // Build path from node up to level 1 (first level after root)
      const path = [];
      let currentNode = node;
      
      while (currentNode && currentNode !== 'Study') {
        path.unshift(currentNode);
        currentNode = originalParentMap.get(currentNode);
        
        // Stop if we reach level 1 (first level after Study)
        if (currentNode === 'Study' || !currentNode) {
          break;
        }
      }
      
      // Add (0) suffix to the final node
      if (path.length > 0) {
        path[path.length - 1] = `${path[path.length - 1]} (0)`;
      }
      
      // Special case: if this is a top-level node (direct child of Study),
      // ensure the path includes the node name twice for proper color lookup
      if (path.length === 1) {
        // This is a top-level node, create path like "Node > Node (0)"
        const topLevelNode = path[0].replace(' (0)', '');
        return `${topLevelNode} > ${path[0]}`;
      }
      
      return path.join(' > ');
    }

    // Handle window resize
    window.addEventListener('resize', function() {
      myChart.resize();
    });

    init();
  </script>
</body>
</html>